- Radiate your gratitude; Focus; Pace Yourself
- Show me your incentive and I will show you the outcome.
- æ¯ä¸€ç§’éƒ½è¦èŠ±ä¿‚æœ€é‡è¦å˜…**äººåŒäº‹**ä¸Šé¢
- How do you feel when you wake up?
    - {{slider}}
        - diaharrea
- #Notes Read https://medium.com/computers-are-hard/computers-are-hard-bugs-and-incidents-with-charity-majors-252813ae9ce8 
    - Topics
        - #[[ðŸ”¢ Software Development]] #Devops
    - Excerpt
        - Timing doesnâ€™t matter. You should just assume that changes are happening
    - literally all the time. Thatâ€™s the only way to plan for risk.
        - Now, instead of The App and The Database you have tens, dozens, 
- hundreds. Youâ€™re depending on all those loosely coupled, far-flung 
- services that arenâ€™t even yours, yet youâ€™re still responsible for your 
- availability.
    - Itâ€™s like a contract everyone in the organization makes with our users. 
- Weâ€™re saying that this is the level of service thatâ€™s acceptable and 
- youâ€™re paying us to provide it. So like, 0.5% failure rate or whatever. 
- Anything better than that we donâ€™t have to obsess about. We can go and 
- build product features until that threshold starts to be threatened in 
- which case itâ€™s all hands on deck. This is really liberating. Itâ€™s a 
- number weâ€™ve all agreed on, so it has potential to ease a lot of 
- frustrations that many teams have had for years and years.
    - You deeply care about the quality of your work â€” itâ€™s your craft, right?
    - You want to build something well and you want your users to be happy. 
- We all have that desire but it has been squeezed out of many of us by 
- shitty on-call rotation and frustrating times when youâ€™re responsible 
- for something but donâ€™t have the tools or the authority to make the 
- change that needs to be made. Thatâ€™s just a recipe for frustration.
    - You canâ€™t predict this stuff. You shouldnâ€™t even try. You should just 
- have the instruments and be good at debugging your system. Thatâ€™s all 
- you can do.
    - I like to think of computers as socio-technical problems. Itâ€™s not just 
- social, itâ€™s not just technical. You can rarely solve a problem just by 
- looking at the tools and you can rarely solve a problem just by looking 
- at humans. They need to work in concert with each other.
    - **Why
    - do some outages take much longer to fix than others? What has to happen
    - for an incident to be so catastrophic that a service stays down for 
- days?** Usually it comes down to data.
    - They ship more consistently, they ship better quality code, and Iâ€™ve had to reckon with my own snobbery and bias.
    - {{[[DONE]]}}  TakeawaysÂ 
        - The purpose of coding is to make the users of your system to be happy.
        - It is very hard, if not impossible to predict where failure will occurs, we should have instruments to detect where it should connect.
        - SLO is a liberating factor. To allow us to not too worry about random errors in the system.
- Timing doesnâ€™t matter. You should just assume that changes are happening
    - literally all the time. Thatâ€™s the only way to plan for risk.
- #Notes Read https://georgefairbanks.com/ieee-software-v32-n4-july-2020-ur-technical-debt 
    - Topics
        - #[[ðŸ”¢ Software Development]]
    - Excerpt
        - Itâ€™s inherent to using an iterative process and acting with a partial understanding.
        - When we use iterative development, itâ€™s inevitable that our ideas will 
- evolve.  Whatâ€™s not inevitable is that we change the code to match our ideas.  Some developers choose to leave existing code alone, following a process of code accretion, or to coin another term, __sedimentary development__.  For a while, you can apply brainpower to reason across the gap between what you understand compared to what you see in the code.
    - The danger is not in using tools, but that the small, automatically-generated, tangible tool output will overshadow the huge, manually-generated, intangible list of debt that can only be identified by skilled developers.
    - see technical debt in a systemâ€™s software architecture as perhaps the worst kind of debt.  Architectural decisions are wickedly expensive to change later, so it is usually worthwhile to spend some time up front (alas, waterfall-style) examining the full problem and trying to choose an architecture, if only to avoid dead-ends that are foreseeable with a bit of effort.
    - The benefits of iteration arenâ€™t free.  Your iterative process must 
- drive code alignment with ideas, otherwise ur-technical debt will doom your project.
    - Different symptoms require different medicine. Inexperienced developers? Try mentoring, career development, and challenges that encourage growth. Oblivious to architecture? Help developers recognize big balls of mud and teach them about design alternatives. Your boss wants a hack to meet a deadline? You must enter the world of management and evaluate the risks to the project or company. If the symptoms are that the code has become tangled, the team canâ€™t meet new requirements quickly, and developers no longer enjoy one of the most intellectually rewarding occupations, then the medicine is iterative development done properly. If we lump all of this under the umbrella of technical debt, then itâ€™s hard to treat the patient.
    - {{[[DONE]]}}  Takeaways
        - Sedimentary development is a way to continuously iterate without refactoring.
        - Technical debt is an umbrella terms for
            - Inexperienced developer
            - Oblivious to architecture
            - Mismanagement
        - The result of technical debt is entangled code and system, hard to maintain and debug system.
        - The requirement cannot be always clear in an iterative workflow.
        - Architectural technical debt is the hardest to pay back.
- [[OKR]] Review with [[Young]] [[Ben Lin]] [[Victor Lam]] [[Hubert Chan]]
    - Next big things in 3-6 months
    - No-blame culture
    - Pricing + Map service -> Data engineer tentative
- How do you feel when you wind down?
    - {{slider}}
