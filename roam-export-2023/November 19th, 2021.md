- {{[[DONE]]}} #Notes Read https://www.oreilly.com/radar/low-code-and-the-democratization-of-programming/ 
    - Why are you reading this?
        - I want to help startup build better service via [[no-code]]
    - Excerpts from the article and some scribble
        - Is it completely out of bounds to say that Python is a low-code language? Perhaps; but it certainly requires much less coding than the languages of the 1960s and ‚Äô70s. Like Excel, though not as successfully, Python has made it possible for people to work with computers who would never have learned C or C++. (The same claim could probably be made for BASIC, and certainly for Visual Basic.)
        - But configuring a tool is almost always simpler than writing the tool yourself. Kelsey Hightower¬†[said](https://oreil.ly/vesCZ)¬†that Kubernetes is the ‚Äúsum of all the bash scripts and best practices that most system administrators would cobble together over time‚Äù; it‚Äôs just that many years of experience have taught us the limitations of endless scripting.
        - As examples go, Kubernetes isn‚Äôt all that unusual. It‚Äôs an example of a ‚Äúdomain-specific language‚Äù (DSL) constructed to solve a specific kind of problem. DSLs enable someone to get a task done without having to describe the whole process from scratch, in immense detail.
        - Excel deservedly comes up in any discussion of low-code programming. So it‚Äôs worth looking at what it does (and let‚Äôs willfully ignore Excel‚Äôs immediate ancestors,¬†[VisiCalc](https://oreil.ly/bchdN)¬†and¬†[Lotus](https://oreil.ly/kWIhe)). Why has Excel succeeded?
        - All of these could be written in Python, and we could argue that most of them could be written in Python with less code. However, in the real world, that‚Äôs not how they‚Äôre written. Formatting is a huge value, in and of itself..
        - On the success of Excel
        - That‚Äôs what we should expect of a low-code language. It isn‚Äôt about the amount of code. It‚Äôs about extending the ability to create to more people by changing paradigms (1D to 2D), eliminating hard parts (like formatting), and limiting what can be done to what most users need to do. This is democratizing.
        - On the failure of UML
        - It reflected a desire to standardize notations for high-level design, rather than rethink it. Excel and other spreadsheets enabled more people to be creative with computers; UML didn‚Äôt.
        - On the failure of LabView
        - As a purely visual language, LabVIEW doesn‚Äôt play well with modern tools for source control, automated testing, and deployment. Still, it‚Äôs an important (and commercially successful) step away from the traditional programming paradigm.
        - On predicting the success of Co-Pilot
        - By reducing the labor of writing code, allowing people to focus their effort on higher-level thought about what they want to do rather than on syntactic correctness, Copilot will certainly make creative computing possible for more people. And that‚Äôs democratization.
        - It‚Äôs that, unlike Excel, and unlike LabVIEW, and unlike Glitch, these tools don‚Äôt really offer new ways to think about problems.
        - This is certainly democratizing: SQL expertise isn‚Äôt expected of most managers‚Äîor, for that matter, of most programmers.
        - Programmers have cast themselves as gurus and rockstars, or as artisans, and to a large extent resisted democratization. In the web space, that has been very explicit: people who use HTML and CSS, but not sophisticated JavaScript, are ‚Äúnot real programmers.‚Äù It‚Äôs almost as if the evolution of the web from a Glitch-like world of copy and paste towards complex web apps took place with the intention of forcing out the great unwashed, and creating an underclass of coding-disabled.
        - Can we go further? Can we enable subject matter experts to build sophisticated applications without needing to communicate their understanding to a group of coders?
        - Blue-collar programmers connect things; white-collar programmers build the things to be connected.
        - The more people who are capable of connecting things, the more things need to be connected. Programmers will be needed to build everything from web widgets to the high-level tools that let citizen programmers do their work.
        - This split matches a reality that we‚Äôve always known. You‚Äôve never needed a four-year computer science degree to get a programming job; you still don‚Äôt. There are many, many programmers who are self-taught, and some startup executives who never entered college (let alone finished it); as one programmer who left a senior position to found a successful startup once said in conversation, ‚ÄúI was making too much money building websites when I was in high school.‚Äù No doubt some of those who never entered college have made significant contributions in algorithms and theory.
        - Traditional colleges and universities pay little attention to the parts of the job that aren‚Äôt software development: teamwork, testing, agile processes, as well as areas of software development that are central to the industry now, such as cloud computing.
        - Picking a good boot camp may be as difficult as choosing an undergraduate college.
        - That‚Äôs an intentionally vague phrase that includes everything from source management (which has a history that goes back to the 1970s) to continuous deployment pipelines. And we have to ask: if useful work is coming from low-code developers, how do we maintain that? What does GitHub for Excel, LabVIEW, or GPT-3 look like?
        - Finally, an inevitable shift in team structure will occur across the industry, allowing programmers to focus on solving with code what low-code solutions can‚Äôt solve, and ensuring that what is solved through low-code solutions is carefully monitored and corrected.
        - Traditional programming languages are (somewhat) good about space; languages like C, C++, and Java require you to define datatypes and data structures. But we have few tools for managing time, and (unsurprisingly) it‚Äôs hard to write concurrent code. Music is all about time management.
        - We‚Äôve talked about digital transformation for years, but relatively few companies have done it. One lesson to take from the COVID pandemic is that every business has to become an online business. When people can‚Äôt go into stores and restaurants, everything from the local pizza shop to the largest retailers needs to be online. When everyone is working at home, they are going to want tools to optimize their work time. Who is going to build all that software? There may not be enough programming talent to go around. There may not be enough of a budget to go around (think about small businesses that need to transact online). And there certainly won‚Äôt be the patience to wait for a project to work its way through an overworked IT department. Forget about yesterday‚Äôs arguments over whether everyone should learn to code. We are entering a business world in which almost everyone will need to code‚Äîand low-, no-, and yes-code frameworks are necessary to enable that. To enable businesses and their citizen programmers to be productive, we may see a proliferation of DSLs: domain-specific languages designed to solve specific problems. And those DSLs will inevitably evolve towards general purpose programming languages: they‚Äôll need web frameworks, cloud capabilities, and more.
    - Further [[ü§î Questions]] to think about
        - Is it true that software engineering is a domain itself?
