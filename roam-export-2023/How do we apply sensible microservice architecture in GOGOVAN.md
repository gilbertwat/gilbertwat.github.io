- **Topics:** #Microservices
- **Status:** #RFC
- 
- Recently, we have a [lot of](https://segment.com/blog/goodbye-microservices/) [discussions](http://highscalability.com/blog/2020/4/8/one-team-at-uber-is-moving-from-microservices-to-macroservic.html) around the topic of microservice. In GOGOVAN, with a relatively small engineering team, how exactly do we apply microservice? In this article, we will share some experience of ours and explore the logic behind our current approach. We will also share bits and pieces on how we solve our customersâ€™ and teammatesâ€™ problems using microservice pattern.
- First we need to agree on a definition of microservice. It is a very heated term and there can be different definitions for every teams. Letâ€™s reference what we have in [Wikipedia](https://en.wikipedia.org/wiki/Microservices):
    - It often has processes that communicate over a network to fulfill a goal using technology-agnostic protocols such as HTTP.
    - Services are  independently deployable.
    - Services are organized around business capabilities.
    - Services can be implemented using different programming languages, databases, hardware and software environment, depending on what fits best.
    - Services are small in size, messaging-enabled, bounded by contexts, autonomously developed, independently deployable, decentralized and built and released with automated processes.
- Hmm, sounds easy. Letâ€™s implement it! Deploy to production!
- Not so fast. Everything comes with a price. Distributed computing is an inherently hard topic in software engineering. And those challenges are not always aligned with our customersâ€™ or teammatesâ€™ needs. In GOGOVAN we have already encountered quite a few. We may be going deep into those rabbit holes later but let me  list out some. You have to apply new tools and techniques to overcome them in a microservice architecture.
- ### How to debug &Â trace?
- It is very hard for us to debug and trace if our requests are not tagged with IDs. Even we have done that, we need to trace independently in each service from the APM or logs for clues. Have you tried to figure which service have defects in real time? You need to open multiple tabs without a proper tracing solution. We donâ€™t think this can scale without significant investment.
- ### Is our data consistent?
- Usually engineers will put a separate services for different business domains. Such as user service, payment serviceâ€¦etc. What if payment service requires a certain attribute in user service? How do we persist it? Do we cache it in the payment service? How should we invalidate it? ðŸ¤¯
- ![There are only 2 hard things in CS: cache invalidation, naming things, and off-by-1 errors. #meme](https://cdn-images-1.medium.com/max/1600/1*xHXwuDEbD3jeto0-sb4Oyw.jpeg)
- ### Failure handling
- Those we can kinda foresee and mitigate in the development phase. Now comes with something more subtle. What will happen when one of your services failed? What will be the behavior of our system? Which APIs will fail? How to do QA?
- ### Do I mention transaction?
- Thing gets more tricky. What if you want to implement transactions across services? For example, you have a feature which only assigning orders to drivers who are validated. You may want to update the **allowed_driver_list** in **Order** Service once the driver is validated in **Driver** Service. Good luck with that.
- ### Do I miss deadlock and livelock?
- The last one is doomed. Currently we have no tool to prevent deadlock and livelock  from happening on a microservice architecture. Other than restarting the affected services, we are not able to prevent it before we deploy on production. This is not good to our reliability.
- ![](https://cdn-images-1.medium.com/max/1600/1*S4feAPzopPWpx8-tokkOsA.jpeg)From reddit (https://www.reddit.com/r/ProgrammerHumor/comments/60pe0k/classic_deadlock/)
- ### And there areÂ moreâ€¦
- Even if you adopt an event streaming platform and event based architecture **from the start, **you are in another technical rabbit hole that is not very related to customersâ€™ problems and our teammatesâ€™ problems. As any impact driven technology team, we cannot afford this.
- ### You donâ€™t want to be high likeÂ meâ€¦
- So microservice architecture is like every other technology patterns, they all come with a cost. How can we evaluate do we need and is you team ready for it?
- ### Do you need microservice architecture?
- [No, you donâ€™t.](https://www.google.com/search?client=firefox-b-d&q=No+we+don%27t+need+microservice)
- Seriously.
- There are only a few  reasons that you need microservice.
- ### Polar opposite need on iteration speed
- On one hand, in some parts of our platform, we need to rapidly deployed to experiment solution to customersâ€™ problems. We deploy new version of those services every other day. On the other hand, we do have some parts of our system that are never changed, for example so integration to legacy third party systems. If we choose to mix them together in 1 codebase, not every developers are aware of the different nature of the modules. This could lead to accidentally coupled them. We will get the worst of both worlds. We make the stable part easy to break but the experimental part too slow to adapt.
- If you are in similar situation as us, you should consider microservice.
- ### Completely different technical requirements
- Some functionalities of our platform requires a < 10ms response time, but some subsystems on our platform needs to process multiple GBs of data. Mixing them together is a recipe of disaster. We once deployed a batch optimized algorithm on a real time use case. ðŸ˜± As a result, one of our critical component is always low on resource and it lowers our platform reliability.
- Another possible case of adopting microservice is we have different requirement of security and legal compliance. Some of our subsystems have strict requirements on privacy or audit, others donâ€™t. Mixing them together will put you at a higher legal or security risk. If you do otherwise, you are able to set different clearances to compartmentalize damages, should a breach occur.
- ### Is your team ready for microservice architecture?
- Let us assume after all your consideration, you are convinced that you need to adopt microservice architecture. How should you determine if your team are ready for it? Can they iterate and operate on it? Here I choose 3 most important elements you must have in your team to adopt a microservice architecture.
- ### TDD Culture
- In software engineering, failure handling is taking us 80% of our time, if not more. TDD culture encourages us to think about how to validate our work. TDD also keeps pushing us to find ways to better defend against regression testing in our system.
- ### Continuous refactoring culture
- As our system grows, some parts will eventually become a hack of a hack of a hack of the original use cases. Our system must be kept to be clear enough to describe the current business processes and able to grow with the business. Most of the subsystems that has a need of separation  mentioned before were not planned. Hence, your team need to be refactoring continuously to meet those needs timely.
- ### Kubernetes
- Your team needs more than the right culture. Your team needs to be proficient in distributed computing from principle to operational. If you are starting now, letâ€™s admit it, Kubernetes has already won. Just learn it and understand the principles behind will fulfill 99.9% of your use cases.
- ### Is there a middle ground from monolith to microservice?
- There are 50 shades of microservices. In GOGOVAN we are doing a lot of in-between tactics  to suit our needs. First and foremost we are migrating to Kubernetes as our microservice infrastructure. Splitting existing functionalities out as a service, or create new services become easier and standardized.
- We also invest a huge effort to adopt continuous refactoring to decouple our codebase using domain driven design and functional programming. Our system is evolving into several loosely coupled components. This allows our teammates to have a deeper understanding of each domains. Having a deeper understanding of their area of expertise also results in higher craftsmanshipÂ , ownership and insights.
- ### Moving forwardâ€¦
- We are fans of functional programming because it can speed up iteration speed and be happier with our code. With a successful adoption of domain driven design and functional programming, we are exploring to further down the road to the area of [strongly typed Ruby](https://sorbet.org/). Also we will continue to excel our knowledge on and around Kubernetes, expanding our knowledge and experience on related topic such as service mesh. Also we increase our usage on our event based architecture and  platform to further decouple our codebase into different areas that can evolve separately.
- Fancy experiencing this journey with a team of open and impact driven engineers? Come chat with [us](mailto:hr@gogotech.hk)!
